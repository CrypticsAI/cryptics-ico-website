<?php 
namespace WpPepVN;

use WpPepVN\DependencyInjection\Injectable
	,WpPepVN\Validation\Exception
	,WpPepVN\Validation\MessageInterface
	,WpPepVN\Validation\Message\Group
	,WpPepVN\Validation\ValidatorInterface
	,WpPepVN\DependencyInjection
;

/**
 * WpPepVN\Validation
 *
 * Allows to validate data using custom or built-in validators
 */
class Validation extends Injectable
{
	protected $_data;

	protected $_entity;

	protected $_validators;

	protected $_filters;

	protected $_messages;

	protected $_defaultMessages;

	protected $_labels;

	protected $_values;

	/**
	 * WpPepVN\Validation constructor
	 */
	public function __construct($validators = null)
	{
		if(is_array($validators)) {
			$this->_validators = $validators;
		}

		$this->setDefaultMessages();

		/**
		 * Check for an 'initialize' method
		 */
		if (method_exists($this, "initialize")) {
			$this->{"initialize"}();
		}
	}

	/**
	 * Validate a set of data according to a set of rules
	 *
	 * @param array|object data
	 * @param object entity
	 * @return WpPepVN\Validation\Message\Group
	 */
	public function validate($data = null, $entity = null)
	{
		if(!is_array($this->_validators)) {
			throw new Exception("There are no validators to validate");
		}

		/**
		 * Clear pre-calculated values
		 */
		$this->_values = null;

		/**
		 * Implicitly creates a WpPepVN\Validation\Message\Group object
		 */
		$messages = new Group();

		/**
		 * Validation classes can implement the 'beforeValidation' callback
		 */
		if (method_exists($this, "beforeValidation")) {
			$status = $this->{"beforeValidation"}($data, $entity, $messages);
			if ($status === false) {
				return $status;
			}
		}

		$this->_messages = $messages;

		if(is_array($data) || is_object($data)) {
			$this->_data = $data;
		}

		foreach($this->_validators as $scope) {

			if(!is_array($scope)) {
				throw new Exception("The validator scope is not valid");
			}

			$field = $scope[0];
			$validator = $scope[1];

			if(!is_object($validator)) {
				throw new Exception("One of the validators is not valid");
			}

			/**
			 * Check if the validation must be canceled if$this validator fails
			 */
			if ($validator->validate($this, $field) === false) {
				if ($validator->getOption("cancelOnFail")) {
					break;
				}
			}
		}

		/**
		 * Get the messages generated by the validators
		 */
		$messages = $this->_messages;
		if (method_exists($this, "afterValidation")) {
			$this->{"afterValidation"}($data, $entity, $messages);
		}

		return $messages;
	}

	/**
	 * Adds a validator to a field
	 */
	public function add($field, $validator)
	{
		$this->_validators[] = array($field, $validator);
		return $this;
	}

	/**
	 * Alias of `add` method
	 */
	public function rule($field, ValidatorInterface $validator)
	{
		return $this->add($field, $validator);
	}

	/**
	 * Adds the validators to a field
	 */
	public function rules($field, $validators)
	{
		
		foreach($validators as $validator) {
			if ($validator instanceof ValidatorInterface) {
				$this->_validators[] = array($field, $validator);
			}
		}
		return $this;
	}

	/**
	 * Adds filters to the field
	 *
	 * @param string field
	 * @param array|string filters
	 * @return WpPepVN\Validation
	 */
	public function setFilters($field, $filters)
	{
		$this->_filters[$field] = $filters;
		return $this;
	}

	/**
	 * Returns all the filters or a specific one
	 *
	 * @param string field
	 * @return mixed
	 */
	public function getFilters($field = null)
	{
		
		if(is_null($field)) {
			return $this->_filters;
		}
		
		if(!isset($this->_filters[$field])) {
			return null;
		}

		return $this->_filters[$field];
	}

	/**
	 * Returns the validators added to the validation
	 */
	public function getValidators()
	{
		return $this->_validators;
	}
	
	/**
	 * Set the validators
	 */
	public function setValidators($validators)
	{
		$this->_validators = $validators;
	}

	/**
	 * Returns the bound entity
	 *
	 * @return object
	 */
	public function getEntity()
	{
		return $this->_entity;
	}

	/**
	 * Adds default messages to validators
	 */
	public function setDefaultMessages($messages = array())
	{
		$defaultMessages = array(
			'Alnum' => 'Field :field must contain only letters and numbers',
			'Alpha' => 'Field :field must contain only letters',
			'Between' => 'Field :field must be within the range of :min to :max',
			'Confirmation' => 'Field :field must be the same as :with',
			'Digit' => 'Field :field must be numeric',
			'Email' => 'Field :field must be an email address',
			'ExclusionIn' => 'Field :field must not be a part of list: :domain',
			'FileEmpty' => 'Field :field must not be empty',
			'FileIniSize' => 'File :field exceeds the maximum file size',
			'FileMaxResolution' => 'File :field must not exceed :max resolution',
			'FileMinResolution' => 'File :field must be at least :min resolution',
			'FileSize' => 'File :field exceeds the size of :max',
			'FileType' => 'File :field must be of type: :types',
			'FileValid' => 'Field :field is not valid',
			'Identical' => 'Field :field does not have the expected value',
			'InclusionIn' => 'Field :field must be a part of list: :domain',
			'Numericality' => 'Field :field does not have a valid numeric format',
			'PresenceOf' => 'Field :field is required',
			'Regex' => 'Field :field does not match the required format',
			'TooLong' => 'Field :field must not exceed :max characters long',
			'TooShort' => 'Field :field must be at least :min characters long',
			'Uniqueness' => 'Field :field must be unique',
			'Url' => 'Field :field must be a url'
		);

		$this->_defaultMessages = array_merge($defaultMessages, $messages);
		return $this->_defaultMessages;
	}

	/**
	 * Get default message for validator type
	 *
	 * @param string type
	 */
	public function getDefaultMessage($type)
	{
		if (!isset ($this->_defaultMessages[$type])) {
			return '';
		}
		return $this->_defaultMessages[$type];
	}

	/**
	 * Returns the registered validators
	 */
	public function getMessages()
	{
		return $this->_messages;
	}

	/**
	 * Adds labels for fields
	 */
	public function setLabels($labels)
	{
		$this->_labels = $labels;
	}

	/**
	 * Get label for field
	 *
	 * @param string field
	 * @return string
	 */
	public function getLabel($field)
	{
		if(isset($this->_labels[$field])) {
			return $this->_labels[$field];
		}
		return $field;
	}

	/**
	 * Appends a message to the messages list
	 */
	public function appendMessage(MessageInterface $message)
	{
		$this->_messages->appendMessage($message);
		return $this;
	}

	/**
	 * Assigns the data to an entity
	 * The entity is used to obtain the validation values
	 *
	 * @param object entity
	 * @param array|object data
	 * @return WpPepVN\Validation
	 */
	public function bind($entity, $data) 
	{
		if(is_object($entity)) {
			throw new Exception("Entity must be an object");
		}

		if(!is_array($data) && !is_object($data)) {
			throw new Exception("Data to validate must be an array or object");
		}

		$this->_entity = $entity;
		$this->_data = $data;

		return $this;
	}

	/**
	 * Gets the a value to validate in the array/object data source
	 *
	 * @param string field
	 * @return mixed
	 */
	public function getValue($field)
	{
		
		$entity = $this->_entity;

		/**
		 * If the entity is an object use it to retrieve the values
		 */
		if(is_object($this->_entity)) {
			$method = "get" . $field;
			if (method_exists($entity, $method)) {
				$value = $entity->{$method}();
			} else {
				if (method_exists($entity, "readAttribute")) {
					$value = $entity->readAttribute($field);
				} else {
					if (isset ($entity->{$field})) {
						$value = $entity->{$field};
					} else {
						$value = null;
					}
				}
			}
			
			return $value;
		}

		$data = $this->_data;

		if(!is_array($data) && !is_object($data)) {
			throw new Exception("There is no data to validate");
		}

		/**
		 * Check if there is a calculated value
		 */
		//$values = $this->_values;
		
		if(isset($this->_values[$field])) {
			return $this->_values[$field];
		}

		$value = null;
		if(is_array($data)) {
			if (isset ($data[$field])) {
				$value = $data[$field];
			}
		} else if (is_object($data)) {
			if (isset ($data->{$field})) {
				$value = $data->{$field};
			}
		}
		
		if(is_null($value)) {
			return null;
		}

		//$filters = $this->_filters;
		if(is_array($this->_filters)) {

			//if fetch fieldFilters, filters[field] 
			if(isset($this->_filters[$field])) {

				if ($this->_filters[$field]) {

					$dependencyInjector = $this->getDI();
					if (!is_object($dependencyInjector)) {
						$dependencyInjector = DependencyInjection::getDefault();
						if (!is_object($dependencyInjector)) {
							throw new Exception("A dependency injector is required to obtain the 'filter' service");
						}
					}

					$filterService = $dependencyInjector->getShared("filter");
					if (!is_object($filterService)) {
						throw new Exception("Returned 'filter' service is invalid");
					}

					return $filterService->sanitize($value, $this->_filters[$field]);
				}
			}
		}

		/**
		 * Cache the calculated value
		 */
		$this->_values[$field] = $value;

		return $value;
	}
}
